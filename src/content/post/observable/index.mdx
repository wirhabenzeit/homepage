---
title: "Reactive Observable Plot with Qwik"
description: "How to render Observable Plot graphics with Qwik, on the server and on the client."
publishDate: "30 Jun 2024"
---

import { Example } from "./example";

[Observable Plot](https://observablehq.com/@observablehq/plot) is a powerful library for creating interactive plots, [Qwik](https://qwik.dev) is a minimalistic web framework that can deliver instant loading web applications. This article shows how to render Observable Plot graphics in Qwik.

## Example

<Example />

## Usage

The `Chart` component has two main props: `plotFunction` and `args`, and some optional props for controlling the rendering:

```
<Chart
    plotFunction={T => Plot.PlotOptions}
    args={Signal<T>}
    fullWidth={boolean?}
    fullHeight={boolean?}
    aspectRatio={number?}
/>
```

Here `plotFunction` is a function accepting an argument of an arbitrary (serializable) type `T` and returning a `Plot.PlotOptions` object. The `args` prop is a Qwik signal containing the argument of type `T`. The plot will be re-rendered whenever the argument changes. The `fullWidth` and `fullHeight` props control whether the plot should take the full width or height of the container. The `aspectRatio` prop can be used to set the aspect ratio of the plot if specifying exactly either the width or height. Note that for server-side rendering it makes sense to set set width and height explicitly, as the container size is not known.

<br />

The following example shows how to use the `Chart` component to render a plot above. Here `Select` is a component changing the value of the `colorby` and `symbolby` signals when the user selects an option.

```tsx
import { $, useSignal, component$, useComputed$ } from "@builder.io/qwik";
import * as d3 from "d3";
import * as Plot from "@observablehq/plot";

import { Chart } from "src/components/plot";
import { Select } from "src/components/inputs";

import csv from "./penguins.csv?raw";
const penguins = d3.csvParse(csv, d3.autoType);

export const Example = component$(() => {
	const colorby = useSignal("species");
	const symbolby = useSignal("island");
	const args = useComputed$(() => ({ stroke: colorby.value, symbol: symbolby.value }));
	const plotFun = $(({ stroke, symbol }: { stroke: string; symbol: string }) => ({
		grid: true,
		color: { legend: true },
		symbol: { legend: true },
		height: 300,
		width: 832,
		marks: [
			Plot.dot(penguins, {
				x: "culmen_length_mm",
				y: "culmen_depth_mm",
				tip: true,
				stroke,
				symbol,
			}),
		],
		title: "Penguin Culmen Length vs Depth",
		subtitle: "Data from Palmer Station, Antarctica",
		caption:
			"Horst AM, Hill AP, Gorman KB (2020). palmerpenguins: Palmer Archipelago (Antarctica) penguin data.",
	}));
	return (
		<div>
			<div class="mb-2 flex gap-5">
				<Select value={colorby} options={["species", "island", "sex"]} label="Color" />
				<Select value={symbolby} options={["species", "island", "sex"]} label="Symbol" />
			</div>
			<Chart plotFunction={plotFun} args={args} fullWidth={true} />
		</div>
	);
});
```

## Code for `Chart`

The implementation of the `Chart` component is shown below. The main ingredients are

- `JSDOM` for server side rendering
- `ResizeObserver` for tracking the size of the container
- `useVisibleTask$` for rendering the plot when the argument signal changes, or the container is resized

```tsx
/** @jsxImportSource @builder.io/qwik */

import {
	component$,
	useComputed$,
	useSignal,
	useVisibleTask$,
	type Signal,
	type QRL,
} from "@builder.io/qwik";

import * as Plot from "@observablehq/plot";
import { JSDOM } from "jsdom";

interface PlotFunction<T> {
	plotFunction: QRL<(x: T) => Plot.PlotOptions>;
	args: Signal<T>;
	class?: string;
	fullWidth?: boolean;
	fullHeight?: boolean;
	aspectRatio?: number;
}

export const Chart = component$<PlotFunction<any>>(
	({ plotFunction, args, class: classList, fullWidth, fullHeight, aspectRatio }) => {
		const jsdom = new JSDOM("");
		global.window = jsdom.window as unknown as Window & typeof globalThis;
		global.document = jsdom.window.document;
		global.Event = jsdom.window.Event;
		global.Node = jsdom.window.Node;
		global.NodeList = jsdom.window.NodeList;
		global.HTMLCollection = jsdom.window.HTMLCollection;

		const outputRef = useSignal<HTMLDivElement | null>(null);
		const width = useSignal(0);
		const height = useSignal(0);

		useVisibleTask$(({ track }) => {
			track(() => outputRef.value);
			if (outputRef.value) {
				const ro = new ResizeObserver((entries) => {
					for (const entry of entries) {
						const rect = entry.contentRect;
						width.value = rect.width;
						height.value = rect.height;
					}
				});
				ro.observe(outputRef.value);
				return () => ro.disconnect();
			}
		});

		const chart = useComputed$(async () => {
			const plotarg = await plotFunction(args.value);
			return Plot.plot(plotarg).outerHTML;
		});

		useVisibleTask$(async ({ track }) => {
			if (!outputRef.value) return;
			if (fullHeight) track(() => height.value);
			if (fullWidth) track(() => width.value);
			track(() => args.value);
			const plotarg = await plotFunction(args.value);
			if (fullWidth && width.value > 0) {
				plotarg.width = width.value;
				if (aspectRatio) plotarg.height = width.value / aspectRatio;
			}
			if (fullHeight && height.value > 0) {
				plotarg.height = height.value;
				if (aspectRatio) plotarg.width = height.value * aspectRatio;
			}
			outputRef.value.innerHTML = "";
			outputRef.value.append(Plot.plot(plotarg));
		});

		return (
			<div
				class={classList ? classList + " not-prose" : "not-prose"}
				ref={outputRef}
				dangerouslySetInnerHTML={chart.value}
			/>
		);
	},
);
```
